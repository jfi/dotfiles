#!/usr/bin/env bash
set -euo pipefail

# Colours
green() { printf "\033[32m%s\033[0m\n" "$*"; }
red() { printf "\033[31m%s\033[0m\n" "$*" >&2; }

DOTFILES_DIR="${HOME}/.dotfiles"

if [ ! -d "${DOTFILES_DIR}" ]; then
  red "Dotfiles repo not found at ${DOTFILES_DIR}"
  echo "Clone it first:" >&2
  echo "  git clone <repo-url> ${DOTFILES_DIR}" >&2
  exit 1
fi

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || {
    red "ERROR: Missing required command: $1"
    exit 1
  }
}

has_cmd() {
  command -v "$1" >/dev/null 2>&1
}

prompt_if_missing() {
  local var_name="$1"
  local prompt="$2"
  local current_value="$3"

  if [ -n "${current_value}" ]; then
    echo "${current_value}"
    return 0
  fi

  # Check if we can read from TTY (works even when stdin is piped)
  if [ -r /dev/tty ]; then
    local value=""
    printf "%s: " "${prompt}" >&2
    read -r value </dev/tty
    if [ -z "${value}" ]; then
      red "ERROR: ${var_name} cannot be empty"
      exit 1
    fi
    echo "${value}"
    return 0
  fi

  red "ERROR: ${var_name} not set and no TTY available"
  exit 1
}

pick_one() {
  local prompt="$1"
  shift
  local options=("$@")

  if [ "${#options[@]}" -eq 0 ]; then
    red "ERROR: No options available for selection."
    echo "Context: ${prompt}" >&2
    exit 1
  fi

  echo "${prompt}" >&2
  local i=1
  for opt in "${options[@]}"; do
    echo "  ${i}) ${opt}" >&2
    i=$((i + 1))
  done

  local choice=""
  while true; do
    printf "Select 1-%d: " "${#options[@]}" >&2
    read -r choice </dev/tty
    if [[ "${choice}" =~ ^[0-9]+$ ]] && [ "${choice}" -ge 1 ] && [ "${choice}" -le "${#options[@]}" ]; then
      echo "${options[$((choice - 1))]}"
      return 0
    fi
    echo "Invalid choice." >&2
  done
}

pick_fuzzy_or_numbered() {
  local prompt="$1"
  shift
  local options=("$@")

  if [ "${#options[@]}" -eq 0 ]; then
    red "ERROR: No options available for selection."
    echo "Context: ${prompt}" >&2
    exit 1
  fi

  if [ -r /dev/tty ] && has_cmd fzf; then
    # fzf reads from pipe and uses /dev/tty for interaction automatically
    printf '%s\n' "${options[@]}" | fzf --prompt "${prompt} " --height 40% --reverse
    return 0
  fi

  pick_one "${prompt}" "${options[@]}"
}

require_op_session() {
  require_cmd op

  if op whoami >/dev/null 2>&1; then
    return 0
  fi

  echo "Signing in to 1Password..." >&2
  op signin >/dev/null

  if ! op whoami >/dev/null 2>&1; then
    red "ERROR: 1Password sign-in did not succeed (op whoami still fails)."
    echo "Try running manually: op signin" >&2
    exit 1
  fi
}

OS="$(uname -s)"

# Load .env if present (but don't require it)
ENV_FILE="${DOTFILES_DIR}/.env"
if [ -f "${ENV_FILE}" ]; then
  # shellcheck disable=SC1090
  source "${ENV_FILE}"
fi

# Resolve git identity (env → .env → interactive)
GIT_NAME="$(prompt_if_missing "DOTFILES_GIT_NAME" "Enter your Git name" "${DOTFILES_GIT_NAME:-}")"
GIT_EMAIL="$(prompt_if_missing "DOTFILES_GIT_EMAIL" "Enter your Git email" "${DOTFILES_GIT_EMAIL:-}")"

# Persist identity to .env if it wasn't already set
if [ -r /dev/tty ]; then
  touch "${ENV_FILE}"
  grep -q '^DOTFILES_GIT_NAME=' "${ENV_FILE}" || echo "DOTFILES_GIT_NAME=\"${GIT_NAME}\"" >> "${ENV_FILE}"
  grep -q '^DOTFILES_GIT_EMAIL=' "${ENV_FILE}" || echo "DOTFILES_GIT_EMAIL=\"${GIT_EMAIL}\"" >> "${ENV_FILE}"
fi

# Decide which per-OS gitconfig to include via ~/.gitconfig.local
GITCONFIG_OS_PATH=""
case "${OS}" in
  Darwin)
    GITCONFIG_OS_PATH="${HOME}/.dotfiles/git/gitconfig.macos"
    ;;
  Linux)
    GITCONFIG_OS_PATH="${HOME}/.dotfiles/git/gitconfig.debian"
    ;;
  *)
    echo "Unsupported OS: ${OS}" >&2
    exit 1
    ;;
esac

# Write ~/.zshrc thin loader
green "Writing ~/.zshrc..."
cat > "${HOME}/.zshrc" <<'EOF'
DOTFILES="$HOME/.dotfiles"

# Shared config
[ -f "$DOTFILES/zsh/zshrc.shared" ] && source "$DOTFILES/zsh/zshrc.shared"

# OS-specific config
case "$(uname -s)" in
  Darwin)
    [ -f "$DOTFILES/zsh/zshrc.macos" ] && source "$DOTFILES/zsh/zshrc.macos"
    ;;
  Linux)
    [ -f "$DOTFILES/zsh/zshrc.debian" ] && source "$DOTFILES/zsh/zshrc.debian"
    ;;
esac
EOF

# Write ~/.zprofile thin loader
green "Writing ~/.zprofile..."
cat > "${HOME}/.zprofile" <<'EOF'
DOTFILES="$HOME/.dotfiles"

[ -f "$DOTFILES/zsh/zprofile.shared" ] && source "$DOTFILES/zsh/zprofile.shared"

case "$(uname -s)" in
  Darwin)
    [ -f "$DOTFILES/zsh/zprofile.macos" ] && source "$DOTFILES/zsh/zprofile.macos"
    ;;
  Linux)
    [ -f "$DOTFILES/zsh/zprofile.debian" ] && source "$DOTFILES/zsh/zprofile.debian"
    ;;
esac
EOF

# Write ~/.tmux.conf thin loader
green "Writing ~/.tmux.conf..."
cat > "${HOME}/.tmux.conf" <<'EOF'
source-file ~/.dotfiles/tmux/tmux.conf.shared
EOF

# Write ~/.gitconfig (shared + local)
green "Writing ~/.gitconfig..."
cat > "${HOME}/.gitconfig" <<'EOF'
[include]
  path = ~/.dotfiles/git/gitconfig.shared

[include]
  path = ~/.gitconfig.local
EOF

# Write ~/.gitconfig.local (machine-specific wiring)
green "Writing ~/.gitconfig.local -> ${GITCONFIG_OS_PATH}..."
cat > "${HOME}/.gitconfig.local" <<EOF
[include]
  path = ${GITCONFIG_OS_PATH}
EOF

chmod 600 "${HOME}/.gitconfig.local" || true

# macOS: create ~/.config/git/allowed_signers using 1Password (vault_id + item_id + field_id)
if [ "${OS}" = "Darwin" ]; then
  if has_cmd op; then
    require_cmd python3
    mkdir -p "${HOME}/.config/git"

    # If already configured in env/.env, reuse it
    OP_VAULT_ID="${DOTFILES_OP_SIGNING_VAULT_ID:-}"
    OP_ITEM_ID="${DOTFILES_OP_SIGNING_ITEM_ID:-}"
    OP_FIELD_ID="${DOTFILES_OP_SIGNING_FIELD_ID:-public_key}"

    # Configure selectors interactively if missing
    if [ -z "${OP_VAULT_ID}" ] || [ -z "${OP_ITEM_ID}" ]; then
      echo "No 1Password signing key selectors set. Let's select them..." >&2
      require_op_session

      # Vault menu: "Name (id)"
      mapfile -t VAULT_MENU < <(
        op vault list --format json | python3 -c '
import json,sys
v=json.load(sys.stdin)
for x in v:
  print(f"{x['\''name'\'']} ({x['\''id'\'']})")
'
      )

      VAULT_PICK="$(pick_fuzzy_or_numbered "Vault>" "${VAULT_MENU[@]}")"
      OP_VAULT_ID="$(printf '%s' "$VAULT_PICK" | sed -n 's/.*(\(.*\)).*/\1/p')"

      # Item menu: "Title (id)" - much nicer with fzf when lots of items
      mapfile -t ITEM_MENU < <(
        op item list --vault "${OP_VAULT_ID}" --format json | python3 -c '
import json,sys
items=json.load(sys.stdin)
for x in items:
  print(f"{x['\''title'\'']} ({x['\''id'\'']})")
'
      )

      ITEM_PICK="$(pick_fuzzy_or_numbered "Item>" "${ITEM_MENU[@]}")"
      OP_ITEM_ID="$(printf '%s' "$ITEM_PICK" | sed -n 's/.*(\(.*\)).*/\1/p')"

      ITEM_JSON="$(op item get "${OP_ITEM_ID}" --vault "${OP_VAULT_ID}" --format json 2>/dev/null || true)"
      if [ -z "$(printf '%s' "${ITEM_JSON}" | tr -d '[:space:]')" ]; then
        red "ERROR: Unable to fetch selected item JSON from 1Password."
        exit 1
      fi

      # Field menu: "field_id (label)" and prefer public_key if present
      mapfile -t FIELD_ID_MENU < <(
        python3 -c '
import json,sys
item=json.load(sys.stdin)
for f in item.get("fields", []):
  fid=(f.get("id") or "").strip()
  label=(f.get("label") or "").strip()
  if fid and label:
    print(f"{fid} ({label})")
' <<<"${ITEM_JSON}"
      )

      if printf '%s\n' "${FIELD_ID_MENU[@]}" | grep -q '^public_key '; then
        OP_FIELD_ID="public_key"
      else
        FIELD_PICK="$(pick_fuzzy_or_numbered "Field>" "${FIELD_ID_MENU[@]}")"
        OP_FIELD_ID="${FIELD_PICK%% *}"
      fi

      echo "Selected 1Password selectors:" >&2
      echo "  DOTFILES_OP_SIGNING_VAULT_ID=${OP_VAULT_ID}" >&2
      echo "  DOTFILES_OP_SIGNING_ITEM_ID=${OP_ITEM_ID}" >&2
      echo "  DOTFILES_OP_SIGNING_FIELD_ID=${OP_FIELD_ID}" >&2

      # Persist to ~/.dotfiles/.env (ignored by git)
      if [ -r /dev/tty ]; then
        touch "${ENV_FILE}"
        {
          echo ""
          echo "# Set by setup on $(date)"
          echo "DOTFILES_OP_SIGNING_VAULT_ID=\"${OP_VAULT_ID}\""
          echo "DOTFILES_OP_SIGNING_ITEM_ID=\"${OP_ITEM_ID}\""
          echo "DOTFILES_OP_SIGNING_FIELD_ID=\"${OP_FIELD_ID}\""
        } >> "${ENV_FILE}"
        echo "Saved 1Password signing key selectors into ${ENV_FILE}" >&2
      fi
    fi

    ITEM_JSON="$(op item get "${OP_ITEM_ID}" --vault "${OP_VAULT_ID}" --format json 2>/dev/null || true)"
    if [ -z "$(printf '%s' "${ITEM_JSON}" | tr -d '[:space:]')" ]; then
      red "ERROR: Unable to fetch 1Password item JSON."
      echo "Try: op item get \"${OP_ITEM_ID}\" --vault \"${OP_VAULT_ID}\" --format json" >&2
      exit 1
    fi

    SIGNING_PUBKEY="$(
      python3 -c '
import json,sys
item=json.load(sys.stdin)
field_id=sys.argv[1]
for f in item.get("fields", []):
  if f.get("id") == field_id:
    v=f.get("value") or ""
    print(str(v).strip())
    raise SystemExit(0)
raise SystemExit(1)
' "${OP_FIELD_ID}" <<<"${ITEM_JSON}" 2>/dev/null || true
    )"

    if [ -z "$(printf '%s' "${SIGNING_PUBKEY}" | tr -d '[:space:]')" ]; then
      red "ERROR: Could not read field '${OP_FIELD_ID}' from 1Password item."
      echo "Hint: for an SSH key item, the field id is often 'public_key'." >&2
      exit 1
    fi

    cat > "${HOME}/.config/git/allowed_signers" <<EOF
${GIT_EMAIL} ${SIGNING_PUBKEY}
EOF

    chmod 600 "${HOME}/.config/git/allowed_signers" || true
    echo "Wrote ~/.config/git/allowed_signers (from 1Password)" >&2

    git config --global user.signingkey "${SIGNING_PUBKEY}"

    if ! git config --get user.signingkey >/dev/null 2>&1; then
      red "ERROR: Failed to set git user.signingkey"
      exit 1
    fi

    echo "Configured git user.signingkey ($(git config --get user.signingkey | cut -c1-32)...)" >&2
  fi
fi

# Write git user configuration (from env / .env / prompt)
git config --global user.name "${GIT_NAME}"
git config --global user.email "${GIT_EMAIL}"

# Install lefthook git hooks if available
if has_cmd lefthook; then
  echo "Installing lefthook git hooks..."
  (cd "${DOTFILES_DIR}" && lefthook install)
fi

echo
green "1-init complete."
echo

# Pause for confirmation before proceeding
if [ -r /dev/tty ]; then
  printf "Press Enter to continue to the next step..." >&2
  read -r </dev/tty
fi
